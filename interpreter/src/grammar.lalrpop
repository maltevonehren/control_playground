use std::str::FromStr;
use crate::ast::{Expression, Program, Statement};

grammar;

pub Program: Program = {
    <Statements> => Program { statements: <> }
};

Statements: Vec<Statement> = {
    <mut list:Statements> <c:Statement> ";" => {
        list.push(c);
        list
    },
    <Statement> ";" => vec![<>],
}

pub(crate) Statement: Statement = {
    <Expression> => Statement::ExpressionStatement(<>),
    <i:Identifier> "=" <e:Expression> => Statement::Assign(i.to_string(), e),
};

pub(crate) Expression: Expression = {
    <Identifier> => Expression::Identifier(<>.to_string()),
    <r#""[^"]*""#> => Expression::StringLiteral(<>.strip_prefix(r#"""#).unwrap().strip_suffix(r#"""#).unwrap().to_string()),
    <Vec> => Expression::VectorLiteral(<>),
    <f:Expression> "(" <args:ExpressionList> ")" =>
        Expression::FunctionCall {
            function: f.into(),
            arguments: args,
        },
};

Vec: Vec<f64> = {
    "[" <NumList> "]" => <>,
};

ExpressionList = Comma<Expression>;
NumList = Comma<Num>;

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Num: f64 = {
    r"-?([0-9]+(\.[0-9]+)?)|(\.[0-9]+)" => f64::from_str(<>).unwrap(),
};

Identifier: &'input str = {
    <r"\p{L}[\p{L}\p{N}_]*">
}
